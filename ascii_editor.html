<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ASCII Diagram Editor</title>
  <link rel="stylesheet" href="style.css">
</head>
<body>
  <!-- Toolbar -->
  <div id="toolbar">
    <button class="tool-btn active" data-tool="select" title="Select (V)">
      <span>Select</span>
      <kbd>V</kbd>
    </button>
    <button class="tool-btn" data-tool="box" title="Box (B)">
      <span>Box</span>
      <kbd>B</kbd>
    </button>
    <button class="tool-btn" data-tool="text" title="Text (T)">
      <span>Text</span>
      <kbd>T</kbd>
    </button>
    <button class="tool-btn" data-tool="line" title="Line (L)">
      <span>Line</span>
      <kbd>L</kbd>
    </button>

    <div class="tool-separator"></div>

    <button class="tool-btn" data-tool="symbol" title="Symbol (S)">
      <span>Symbol</span>
      <kbd>S</kbd>
    </button>
    <button class="tool-btn" data-tool="wire" title="Wire (W)">
      <span>Wire</span>
      <kbd>W</kbd>
    </button>
    <button class="tool-btn" data-tool="port" title="Port (P)">
      <span>Port</span>
      <kbd>P</kbd>
    </button>
    <button class="tool-btn" data-tool="power" title="Power (O)">
      <span>Power</span>
      <kbd>O</kbd>
    </button>

    <div class="toolbar-spacer"></div>

    <button class="tool-btn" id="btn-undo" title="Undo (Ctrl+Z)">Undo</button>
    <button class="tool-btn" id="btn-redo" title="Redo (Ctrl+Y)">Redo</button>

    <div class="tool-separator"></div>

    <button class="tool-btn" id="btn-grid" title="Toggle Grid (G)">Grid</button>
    <button class="tool-btn" id="btn-export" title="Export ASCII (Ctrl+E)">Export</button>
    <button class="tool-btn" id="btn-save" title="Save (Ctrl+S)">Save</button>
    <button class="tool-btn" id="btn-load" title="Load">Load</button>
  </div>

  <!-- Main Content -->
  <div id="main-content">
    <div id="canvas-container">
      <div id="canvas-wrapper">
        <canvas id="editor-canvas"></canvas>
        <!-- Inline text editor overlay -->
        <textarea id="inline-editor" spellcheck="false"></textarea>
      </div>
      <div id="page-tabs">
        <!-- Tabs populated by JS -->
      </div>
    </div>

    <!-- Properties Panel -->
    <div id="properties-panel">
      <div class="panel-header">Properties</div>
      <div id="properties-content">
        <div class="property-empty">No selection</div>
      </div>
    </div>
  </div>

  <!-- Status Bar -->
  <div id="status-bar">
    <span class="status-item" id="status-tool">Tool: Select</span>
    <span class="status-item" id="status-position">Col: 0, Row: 0</span>
    <span class="status-item" id="status-selection">Selected: 0</span>
    <span class="status-item" id="status-zoom">Zoom: 100%</span>
    <span class="status-item" id="status-page">Page: 1/1</span>
    <div style="flex:1"></div>
    <span class="status-item" id="status-history">History: 0/0</span>
  </div>

  <script>
    // ============================================================
    // UTILITIES
    // ============================================================

    function generateId() {
      return 'id-' + Math.random().toString(36).substr(2, 9);
    }

    function clamp(value, min, max) {
      return Math.min(Math.max(value, min), max);
    }

    function deepClone(obj) {
      return JSON.parse(JSON.stringify(obj));
    }

    // ============================================================
    // CHARACTER GRID
    // ============================================================

    class CharacterGrid {
      constructor(charWidth, charHeight) {
        this.charWidth = charWidth;
        this.charHeight = charHeight;
      }

      // Pixel to character coordinates
      pixelToChar(px, py) {
        return {
          col: Math.floor(px / this.charWidth),
          row: Math.floor(py / this.charHeight)
        };
      }

      // Character to pixel coordinates (top-left of cell)
      charToPixel(col, row) {
        return {
          x: col * this.charWidth,
          y: row * this.charHeight
        };
      }

      // Get pixel bounds for a character cell
      getCellBounds(col, row) {
        return {
          x: col * this.charWidth,
          y: row * this.charHeight,
          width: this.charWidth,
          height: this.charHeight
        };
      }

      // Snap pixel coordinates to grid
      snapToGrid(px, py) {
        const char = this.pixelToChar(px, py);
        return this.charToPixel(char.col, char.row);
      }
    }

    // ============================================================
    // COMMAND PATTERN (for Undo/Redo)
    // ============================================================

    class Command {
      execute(state) { return state; }
      undo(state) { return state; }
      canMerge(other) { return false; }
      merge(other) { return this; }
    }

    class CreateObjectCommand extends Command {
      constructor(pageId, object) {
        super();
        this.pageId = pageId;
        this.object = object;
      }

      execute(state) {
        const newState = deepClone(state);
        const page = newState.project.pages.find(p => p.id === this.pageId);
        if (page) {
          page.objects.push(this.object);
        }
        return newState;
      }

      undo(state) {
        const newState = deepClone(state);
        const page = newState.project.pages.find(p => p.id === this.pageId);
        if (page) {
          page.objects = page.objects.filter(o => o.id !== this.object.id);
        }
        return newState;
      }
    }

    class DeleteObjectCommand extends Command {
      constructor(pageId, object) {
        super();
        this.pageId = pageId;
        this.object = object;
      }

      execute(state) {
        const newState = deepClone(state);
        const page = newState.project.pages.find(p => p.id === this.pageId);
        if (page) {
          page.objects = page.objects.filter(o => o.id !== this.object.id);
        }
        return newState;
      }

      undo(state) {
        const newState = deepClone(state);
        const page = newState.project.pages.find(p => p.id === this.pageId);
        if (page) {
          page.objects.push(this.object);
        }
        return newState;
      }
    }

    class MoveObjectCommand extends Command {
      constructor(pageId, objectId, fromPos, toPos) {
        super();
        this.pageId = pageId;
        this.objectId = objectId;
        this.fromPos = fromPos;
        this.toPos = toPos;
      }

      execute(state) {
        const newState = deepClone(state);
        const page = newState.project.pages.find(p => p.id === this.pageId);
        if (page) {
          const obj = page.objects.find(o => o.id === this.objectId);
          if (obj) {
            obj.x = this.toPos.x;
            obj.y = this.toPos.y;
          }
        }
        return newState;
      }

      undo(state) {
        const newState = deepClone(state);
        const page = newState.project.pages.find(p => p.id === this.pageId);
        if (page) {
          const obj = page.objects.find(o => o.id === this.objectId);
          if (obj) {
            obj.x = this.fromPos.x;
            obj.y = this.fromPos.y;
          }
        }
        return newState;
      }

      canMerge(other) {
        return other instanceof MoveObjectCommand &&
               other.objectId === this.objectId &&
               other.pageId === this.pageId;
      }

      merge(other) {
        return new MoveObjectCommand(this.pageId, this.objectId, this.fromPos, other.toPos);
      }
    }

    class ModifyObjectCommand extends Command {
      constructor(pageId, objectId, oldProps, newProps) {
        super();
        this.pageId = pageId;
        this.objectId = objectId;
        this.oldProps = oldProps;
        this.newProps = newProps;
      }

      execute(state) {
        const newState = deepClone(state);
        const page = newState.project.pages.find(p => p.id === this.pageId);
        if (page) {
          const obj = page.objects.find(o => o.id === this.objectId);
          if (obj) {
            Object.assign(obj, this.newProps);
          }
        }
        return newState;
      }

      undo(state) {
        const newState = deepClone(state);
        const page = newState.project.pages.find(p => p.id === this.pageId);
        if (page) {
          const obj = page.objects.find(o => o.id === this.objectId);
          if (obj) {
            Object.assign(obj, this.oldProps);
          }
        }
        return newState;
      }
    }

    // ============================================================
    // HISTORY MANAGER
    // ============================================================

    class HistoryManager {
      constructor(initialState, maxHistory = 100) {
        this.state = initialState;
        this.undoStack = [];
        this.redoStack = [];
        this.maxHistory = maxHistory;
        this.listeners = [];
      }

      getState() {
        return this.state;
      }

      execute(command) {
        // Try to merge with last command
        if (this.undoStack.length > 0) {
          const last = this.undoStack[this.undoStack.length - 1];
          if (last.canMerge && last.canMerge(command)) {
            this.undoStack[this.undoStack.length - 1] = last.merge(command);
            this.state = command.execute(this.state);
            this.redoStack = [];
            this.notifyListeners();
            return;
          }
        }

        this.state = command.execute(this.state);
        this.undoStack.push(command);
        this.redoStack = [];

        // Limit history size
        if (this.undoStack.length > this.maxHistory) {
          this.undoStack.shift();
        }

        this.notifyListeners();
      }

      undo() {
        if (this.undoStack.length === 0) return false;
        const command = this.undoStack.pop();
        this.state = command.undo(this.state);
        this.redoStack.push(command);
        this.notifyListeners();
        return true;
      }

      redo() {
        if (this.redoStack.length === 0) return false;
        const command = this.redoStack.pop();
        this.state = command.execute(this.state);
        this.undoStack.push(command);
        this.notifyListeners();
        return true;
      }

      canUndo() {
        return this.undoStack.length > 0;
      }

      canRedo() {
        return this.redoStack.length > 0;
      }

      subscribe(listener) {
        this.listeners.push(listener);
        return () => {
          this.listeners = this.listeners.filter(l => l !== listener);
        };
      }

      notifyListeners() {
        this.listeners.forEach(l => l(this.state));
      }

      // Direct state update (for non-undoable changes like selection, view state)
      updateState(updater) {
        this.state = updater(this.state);
        this.notifyListeners();
      }
    }

    // ============================================================
    // TOOL BASE CLASS
    // ============================================================

    class Tool {
      constructor(name) {
        this.name = name;
        this.cursor = 'default';
      }

      activate(context) {}
      deactivate() {}

      onMouseDown(event, context) { return false; }
      onMouseMove(event, context) { return false; }
      onMouseUp(event, context) { return false; }
      onKeyDown(event, context) { return false; }
      onKeyUp(event, context) { return false; }
      onDoubleClick(event, context) { return false; }

      renderOverlay(ctx, context) {}
    }

    // ============================================================
    // SELECT TOOL
    // ============================================================

    // Interaction modes for SelectTool
    const SelectMode = {
      NONE: 'none',
      DRAGGING: 'dragging',           // Moving selected object(s)
      MARQUEE: 'marquee',             // Drawing selection rectangle
      RESIZING: 'resizing'            // Resizing single object
    };

    // Resize handle positions
    const HandlePosition = {
      TOP_LEFT: 'tl',
      TOP_RIGHT: 'tr',
      BOTTOM_LEFT: 'bl',
      BOTTOM_RIGHT: 'br'
    };

    class SelectTool extends Tool {
      constructor() {
        super('select');
        this.cursor = 'default';
        this.mode = SelectMode.NONE;
        this.dragStart = null;
        this.dragCurrent = null;
        this.draggedIds = [];
        this.originalPositions = {};
        this.activeHandle = null;
        this.resizeOriginal = null;
        this.addToSelection = false;  // Ctrl key held
      }

      activate(context) {
        this.resetState();
        context.canvas.style.cursor = this.cursor;
      }

      deactivate() {
        this.resetState();
      }

      resetState() {
        this.mode = SelectMode.NONE;
        this.dragStart = null;
        this.dragCurrent = null;
        this.draggedIds = [];
        this.originalPositions = {};
        this.activeHandle = null;
        this.resizeOriginal = null;
        this.addToSelection = false;
      }

      onMouseDown(event, context) {
        const { col, row } = context.grid.pixelToChar(event.canvasX, event.canvasY);
        const state = context.history.getState();
        this.addToSelection = event.ctrlKey;
        this.dragStart = { col, row, pixelX: event.canvasX, pixelY: event.canvasY };
        this.dragCurrent = { col, row };

        // Check for resize handle hit (single selection only)
        if (state.selection.ids.length === 1) {
          const handle = this.hitTestHandle(event.canvasX, event.canvasY, context);
          if (handle) {
            this.mode = SelectMode.RESIZING;
            this.activeHandle = handle.position;
            this.resizeOriginal = { ...handle.obj };
            return true;
          }
        }

        // Check for object hit
        const hit = this.hitTestObject(col, row, context);

        if (hit) {
          const isAlreadySelected = state.selection.ids.includes(hit.id);

          if (event.ctrlKey) {
            // Ctrl+click: toggle selection
            if (isAlreadySelected) {
              context.history.updateState(s => ({
                ...s,
                selection: {
                  ids: s.selection.ids.filter(id => id !== hit.id),
                  handles: null
                }
              }));
            } else {
              context.history.updateState(s => ({
                ...s,
                selection: {
                  ids: [...s.selection.ids, hit.id],
                  handles: null
                }
              }));
            }
          } else {
            // Regular click: select this object (or keep multi-selection if clicking selected)
            if (!isAlreadySelected) {
              context.history.updateState(s => ({
                ...s,
                selection: { ids: [hit.id], handles: null }
              }));
            }
          }

          // Prepare for dragging
          this.mode = SelectMode.DRAGGING;
          const currentState = context.history.getState();
          this.draggedIds = [...currentState.selection.ids];

          // Store original positions of all selected objects
          const page = currentState.project.pages.find(p => p.id === currentState.activePageId);
          if (page) {
            this.originalPositions = {};
            this.draggedIds.forEach(id => {
              const obj = page.objects.find(o => o.id === id);
              if (obj) {
                this.originalPositions[id] = { x: obj.x, y: obj.y };
              }
            });
          }
        } else {
          // Click on empty space - start marquee or deselect
          if (!event.ctrlKey) {
            context.history.updateState(s => ({
              ...s,
              selection: { ids: [], handles: null }
            }));
          }
          this.mode = SelectMode.MARQUEE;
        }

        return true;
      }

      onMouseMove(event, context) {
        const { col, row } = context.grid.pixelToChar(event.canvasX, event.canvasY);
        this.dragCurrent = { col, row, pixelX: event.canvasX, pixelY: event.canvasY };

        if (this.mode === SelectMode.DRAGGING && this.draggedIds.length > 0) {
          // Move all selected objects
          const dx = col - this.dragStart.col;
          const dy = row - this.dragStart.row;

          context.history.updateState(state => {
            const newState = deepClone(state);
            const page = newState.project.pages.find(p => p.id === state.activePageId);
            if (page) {
              this.draggedIds.forEach(id => {
                const obj = page.objects.find(o => o.id === id);
                const orig = this.originalPositions[id];
                if (obj && orig) {
                  obj.x = orig.x + dx;
                  obj.y = orig.y + dy;
                }
              });
            }
            return newState;
          });
          return true;
        }

        if (this.mode === SelectMode.RESIZING && this.resizeOriginal) {
          this.performResize(col, row, context);
          return true;
        }

        if (this.mode === SelectMode.MARQUEE) {
          return true;  // Just redraw to show marquee
        }

        // Update cursor based on what's under mouse
        const state = context.history.getState();
        if (state.selection.ids.length === 1) {
          const handle = this.hitTestHandle(event.canvasX, event.canvasY, context);
          if (handle) {
            context.canvas.style.cursor = this.getHandleCursor(handle.position);
            return false;
          }
        }

        const hit = this.hitTestObject(col, row, context);
        context.canvas.style.cursor = hit ? 'move' : 'default';

        return false;
      }

      onMouseUp(event, context) {
        const { col, row } = context.grid.pixelToChar(event.canvasX, event.canvasY);

        if (this.mode === SelectMode.DRAGGING && this.draggedIds.length > 0) {
          const dx = col - this.dragStart.col;
          const dy = row - this.dragStart.row;

          if (dx !== 0 || dy !== 0) {
            // Restore original positions first
            context.history.updateState(state => {
              const newState = deepClone(state);
              const page = newState.project.pages.find(p => p.id === state.activePageId);
              if (page) {
                this.draggedIds.forEach(id => {
                  const obj = page.objects.find(o => o.id === id);
                  const orig = this.originalPositions[id];
                  if (obj && orig) {
                    obj.x = orig.x;
                    obj.y = orig.y;
                  }
                });
              }
              return newState;
            });

            // Execute move commands for undo/redo
            const state = context.history.getState();
            this.draggedIds.forEach(id => {
              const orig = this.originalPositions[id];
              if (orig) {
                context.history.execute(new MoveObjectCommand(
                  state.activePageId,
                  id,
                  orig,
                  { x: orig.x + dx, y: orig.y + dy }
                ));
              }
            });
          }
        }

        if (this.mode === SelectMode.RESIZING && this.resizeOriginal) {
          this.finalizeResize(context);
        }

        if (this.mode === SelectMode.MARQUEE) {
          this.performMarqueeSelect(context);
        }

        this.resetState();
        return true;
      }

      onKeyDown(event, context) {
        const state = context.history.getState();

        // Delete selected objects
        if (event.key === 'Delete' || event.key === 'Backspace') {
          if (state.selection.ids.length > 0) {
            const page = state.project.pages.find(p => p.id === state.activePageId);
            if (page) {
              // Create delete commands for all selected
              state.selection.ids.forEach(id => {
                const obj = page.objects.find(o => o.id === id);
                if (obj) {
                  context.history.execute(new DeleteObjectCommand(state.activePageId, deepClone(obj)));
                }
              });
              context.history.updateState(s => ({
                ...s,
                selection: { ids: [], handles: null }
              }));
            }
            return true;
          }
        }

        // Type to edit: if single box selected and printable key pressed, start editing
        if (state.selection.ids.length === 1 && event.key.length === 1 && !event.ctrlKey && !event.altKey) {
          const page = state.project.pages.find(p => p.id === state.activePageId);
          if (page) {
            const obj = page.objects.find(o => o.id === state.selection.ids[0]);
            if (obj && obj.type === 'box' && context.startInlineEdit) {
              context.startInlineEdit(obj, event.key);  // Pass initial character
              return true;
            }
          }
        }

        return false;
      }

      onDoubleClick(event, context) {
        const { col, row } = context.grid.pixelToChar(event.canvasX, event.canvasY);
        const hit = this.hitTestObject(col, row, context);

        if (hit && hit.type === 'box') {
          // Start inline editing
          if (context.startInlineEdit) {
            context.startInlineEdit(hit);
          }
          return true;
        }
        return false;
      }

      performResize(col, row, context) {
        const state = context.history.getState();
        const page = state.project.pages.find(p => p.id === state.activePageId);
        if (!page) return;

        const obj = page.objects.find(o => o.id === state.selection.ids[0]);
        if (!obj) return;

        const orig = this.resizeOriginal;
        let newX = orig.x;
        let newY = orig.y;
        let newW = orig.width;
        let newH = orig.height;

        const minSize = 3;

        switch (this.activeHandle) {
          case HandlePosition.TOP_LEFT:
            newX = Math.min(col, orig.x + orig.width - minSize);
            newY = Math.min(row, orig.y + orig.height - minSize);
            newW = orig.x + orig.width - newX;
            newH = orig.y + orig.height - newY;
            break;
          case HandlePosition.TOP_RIGHT:
            newY = Math.min(row, orig.y + orig.height - minSize);
            newW = Math.max(minSize, col - orig.x + 1);
            newH = orig.y + orig.height - newY;
            break;
          case HandlePosition.BOTTOM_LEFT:
            newX = Math.min(col, orig.x + orig.width - minSize);
            newW = orig.x + orig.width - newX;
            newH = Math.max(minSize, row - orig.y + 1);
            break;
          case HandlePosition.BOTTOM_RIGHT:
            newW = Math.max(minSize, col - orig.x + 1);
            newH = Math.max(minSize, row - orig.y + 1);
            break;
        }

        context.history.updateState(s => {
          const newState = deepClone(s);
          const pg = newState.project.pages.find(p => p.id === s.activePageId);
          if (pg) {
            const o = pg.objects.find(ob => ob.id === s.selection.ids[0]);
            if (o) {
              o.x = newX;
              o.y = newY;
              o.width = newW;
              o.height = newH;
            }
          }
          return newState;
        });
      }

      finalizeResize(context) {
        const state = context.history.getState();
        const page = state.project.pages.find(p => p.id === state.activePageId);
        if (!page) return;

        const obj = page.objects.find(o => o.id === state.selection.ids[0]);
        if (!obj) return;

        const orig = this.resizeOriginal;
        const hasChanged = obj.x !== orig.x || obj.y !== orig.y ||
                          obj.width !== orig.width || obj.height !== orig.height;

        if (hasChanged) {
          const newProps = { x: obj.x, y: obj.y, width: obj.width, height: obj.height };

          // Restore original
          context.history.updateState(s => {
            const newState = deepClone(s);
            const pg = newState.project.pages.find(p => p.id === s.activePageId);
            if (pg) {
              const o = pg.objects.find(ob => ob.id === s.selection.ids[0]);
              if (o) {
                o.x = orig.x;
                o.y = orig.y;
                o.width = orig.width;
                o.height = orig.height;
              }
            }
            return newState;
          });

          // Execute command for undo/redo
          context.history.execute(new ModifyObjectCommand(
            state.activePageId,
            obj.id,
            { x: orig.x, y: orig.y, width: orig.width, height: orig.height },
            newProps
          ));
        }
      }

      performMarqueeSelect(context) {
        if (!this.dragStart || !this.dragCurrent) return;

        const state = context.history.getState();
        const page = state.project.pages.find(p => p.id === state.activePageId);
        if (!page) return;

        const x1 = Math.min(this.dragStart.col, this.dragCurrent.col);
        const y1 = Math.min(this.dragStart.row, this.dragCurrent.row);
        const x2 = Math.max(this.dragStart.col, this.dragCurrent.col);
        const y2 = Math.max(this.dragStart.row, this.dragCurrent.row);

        // Determine selection mode based on drag direction
        const leftToRight = this.dragCurrent.col >= this.dragStart.col;

        const selectedIds = [];
        page.objects.forEach(obj => {
          const objX1 = obj.x;
          const objY1 = obj.y;
          const objX2 = obj.x + (obj.width || 10) - 1;
          const objY2 = obj.y + (obj.height || 3) - 1;

          let selected = false;

          if (leftToRight) {
            // Enclosed mode: object must be fully inside marquee
            selected = objX1 >= x1 && objX2 <= x2 && objY1 >= y1 && objY2 <= y2;
          } else {
            // Intersect mode: object just needs to touch marquee
            selected = !(objX2 < x1 || objX1 > x2 || objY2 < y1 || objY1 > y2);
          }

          if (selected) {
            selectedIds.push(obj.id);
          }
        });

        // If Ctrl held, add to existing selection
        if (this.addToSelection) {
          const existingIds = state.selection.ids;
          const newIds = [...new Set([...existingIds, ...selectedIds])];
          context.history.updateState(s => ({
            ...s,
            selection: { ids: newIds, handles: null }
          }));
        } else {
          context.history.updateState(s => ({
            ...s,
            selection: { ids: selectedIds, handles: null }
          }));
        }
      }

      hitTestObject(col, row, context) {
        const state = context.history.getState();
        const page = state.project.pages.find(p => p.id === state.activePageId);
        if (!page) return null;

        // Check objects in reverse order (top-most first)
        for (let i = page.objects.length - 1; i >= 0; i--) {
          const obj = page.objects[i];
          if (this.objectContainsPoint(obj, col, row)) {
            return obj;
          }
        }
        return null;
      }

      hitTestHandle(pixelX, pixelY, context) {
        const state = context.history.getState();
        if (state.selection.ids.length !== 1) return null;

        const page = state.project.pages.find(p => p.id === state.activePageId);
        if (!page) return null;

        const obj = page.objects.find(o => o.id === state.selection.ids[0]);
        if (!obj) return null;

        const { x, y } = context.grid.charToPixel(obj.x, obj.y);
        const width = (obj.width || 10) * context.grid.charWidth;
        const height = (obj.height || 3) * context.grid.charHeight;

        const handleSize = 8;
        const handles = [
          { position: HandlePosition.TOP_LEFT, hx: x, hy: y },
          { position: HandlePosition.TOP_RIGHT, hx: x + width, hy: y },
          { position: HandlePosition.BOTTOM_LEFT, hx: x, hy: y + height },
          { position: HandlePosition.BOTTOM_RIGHT, hx: x + width, hy: y + height }
        ];

        for (const h of handles) {
          if (Math.abs(pixelX - h.hx) <= handleSize && Math.abs(pixelY - h.hy) <= handleSize) {
            return { position: h.position, obj };
          }
        }

        return null;
      }

      getHandleCursor(position) {
        switch (position) {
          case HandlePosition.TOP_LEFT:
          case HandlePosition.BOTTOM_RIGHT:
            return 'nwse-resize';
          case HandlePosition.TOP_RIGHT:
          case HandlePosition.BOTTOM_LEFT:
            return 'nesw-resize';
          default:
            return 'default';
        }
      }

      objectContainsPoint(obj, col, row) {
        const width = obj.width || 10;
        const height = obj.height || 3;
        return col >= obj.x && col < obj.x + width &&
               row >= obj.y && row < obj.y + height;
      }

      renderOverlay(ctx, context) {
        const state = context.history.getState();
        const page = state.project.pages.find(p => p.id === state.activePageId);
        if (!page) return;

        // Get CSS variables for colors
        const styles = getComputedStyle(document.documentElement);
        const selectionStroke = styles.getPropertyValue('--selection-stroke').trim() || '#007acc';
        const marqueeEnclosedStroke = styles.getPropertyValue('--marquee-enclosed-stroke').trim() || '#007acc';
        const marqueeEnclosedFill = styles.getPropertyValue('--marquee-enclosed-fill').trim() || 'rgba(0, 122, 204, 0.1)';
        const marqueeIntersectStroke = styles.getPropertyValue('--marquee-intersect-stroke').trim() || '#00cc7a';
        const marqueeIntersectFill = styles.getPropertyValue('--marquee-intersect-fill').trim() || 'rgba(0, 204, 122, 0.1)';

        // Draw marquee selection rectangle
        if (this.mode === SelectMode.MARQUEE && this.dragStart && this.dragCurrent) {
          const x1 = Math.min(this.dragStart.pixelX, this.dragCurrent.pixelX);
          const y1 = Math.min(this.dragStart.pixelY, this.dragCurrent.pixelY);
          const w = Math.abs(this.dragCurrent.pixelX - this.dragStart.pixelX);
          const h = Math.abs(this.dragCurrent.pixelY - this.dragStart.pixelY);

          const leftToRight = this.dragCurrent.col >= this.dragStart.col;

          ctx.lineWidth = 1;

          if (leftToRight) {
            // Enclosed mode: solid line
            ctx.setLineDash([]);
            ctx.strokeStyle = marqueeEnclosedStroke;
            ctx.fillStyle = marqueeEnclosedFill;
          } else {
            // Intersect mode: dashed line
            ctx.setLineDash([4, 4]);
            ctx.strokeStyle = marqueeIntersectStroke;
            ctx.fillStyle = marqueeIntersectFill;
          }

          ctx.fillRect(x1, y1, w, h);
          ctx.strokeRect(x1, y1, w, h);
          ctx.setLineDash([]);
        }

        // Draw selection rectangles for each selected object
        const isSingleSelection = state.selection.ids.length === 1;

        state.selection.ids.forEach(id => {
          const obj = page.objects.find(o => o.id === id);
          if (obj) {
            const { x, y } = context.grid.charToPixel(obj.x, obj.y);
            const width = (obj.width || 10) * context.grid.charWidth;
            const height = (obj.height || 3) * context.grid.charHeight;

            ctx.strokeStyle = selectionStroke;
            ctx.lineWidth = 1;
            ctx.setLineDash([]);
            ctx.strokeRect(x - 1, y - 1, width + 2, height + 2);

            // Draw resize handles only for single selection
            if (isSingleSelection) {
              const handleSize = 6;
              ctx.fillStyle = selectionStroke;

              // Corner handles
              ctx.fillRect(x - handleSize/2, y - handleSize/2, handleSize, handleSize);
              ctx.fillRect(x + width - handleSize/2, y - handleSize/2, handleSize, handleSize);
              ctx.fillRect(x - handleSize/2, y + height - handleSize/2, handleSize, handleSize);
              ctx.fillRect(x + width - handleSize/2, y + height - handleSize/2, handleSize, handleSize);
            }
          }
        });
      }
    }

    // ============================================================
    // BOX TOOL
    // ============================================================

    class BoxTool extends Tool {
      constructor() {
        super('box');
        this.cursor = 'crosshair';
        this.drawing = false;
        this.startPos = null;
        this.currentPos = null;
      }

      activate(context) {
        this.drawing = false;
        context.canvas.style.cursor = this.cursor;
      }

      onMouseDown(event, context) {
        const { col, row } = context.grid.pixelToChar(event.canvasX, event.canvasY);
        this.drawing = true;
        this.startPos = { col, row };
        this.currentPos = { col, row };
        return true;
      }

      onMouseMove(event, context) {
        if (this.drawing) {
          const { col, row } = context.grid.pixelToChar(event.canvasX, event.canvasY);
          this.currentPos = { col, row };
          return true; // Request redraw
        }
        return false;
      }

      onMouseUp(event, context) {
        if (this.drawing) {
          const { col, row } = context.grid.pixelToChar(event.canvasX, event.canvasY);
          this.currentPos = { col, row };

          // Calculate box bounds
          const x = Math.min(this.startPos.col, this.currentPos.col);
          const y = Math.min(this.startPos.row, this.currentPos.row);
          const width = Math.abs(this.currentPos.col - this.startPos.col) + 1;
          const height = Math.abs(this.currentPos.row - this.startPos.row) + 1;

          // Minimum size
          if (width >= 3 && height >= 3) {
            const state = context.history.getState();
            const newBox = {
              id: generateId(),
              type: 'box',
              x, y, width, height,
              text: '',
              style: 'single',  // single, double, rounded
              shadow: false,
              textJustify: 'center-center',  // vertical-horizontal: top/center/bottom - left/center/right
              title: '',
              titlePosition: 'top-left',  // top-left, top-center, top-right, bottom-left, bottom-center, bottom-right
              titleMode: 'border'  // border (on line), inside, outside
            };

            context.history.execute(new CreateObjectCommand(state.activePageId, newBox));

            // Select the new box
            context.history.updateState(s => ({
              ...s,
              selection: { ids: [newBox.id], handles: null }
            }));
          }

          this.drawing = false;
          this.startPos = null;
          this.currentPos = null;
          return true;
        }
        return false;
      }

      renderOverlay(ctx, context) {
        if (this.drawing && this.startPos && this.currentPos) {
          const x = Math.min(this.startPos.col, this.currentPos.col);
          const y = Math.min(this.startPos.row, this.currentPos.row);
          const width = Math.abs(this.currentPos.col - this.startPos.col) + 1;
          const height = Math.abs(this.currentPos.row - this.startPos.row) + 1;

          const pixelPos = context.grid.charToPixel(x, y);
          const pixelWidth = width * context.grid.charWidth;
          const pixelHeight = height * context.grid.charHeight;

          const styles = getComputedStyle(document.documentElement);
          const accent = styles.getPropertyValue('--accent').trim() || '#007acc';

          ctx.strokeStyle = accent;
          ctx.lineWidth = 1;
          ctx.setLineDash([5, 3]);
          ctx.strokeRect(pixelPos.x, pixelPos.y, pixelWidth, pixelHeight);
          ctx.setLineDash([]);

          // Size indicator
          ctx.fillStyle = accent;
          ctx.font = '11px sans-serif';
          ctx.fillText(`${width}x${height}`, pixelPos.x + 4, pixelPos.y - 4);
        }
      }
    }

    // ============================================================
    // TOOL MANAGER
    // ============================================================

    class ToolManager {
      constructor() {
        this.tools = {};
        this.activeTool = null;
        this.context = null;
      }

      register(tool) {
        this.tools[tool.name] = tool;
      }

      setContext(context) {
        this.context = context;
      }

      activate(toolName) {
        if (this.activeTool) {
          this.activeTool.deactivate();
        }

        const tool = this.tools[toolName];
        if (tool) {
          this.activeTool = tool;
          tool.activate(this.context);
          return true;
        }
        return false;
      }

      getActiveTool() {
        return this.activeTool;
      }

      onMouseDown(event) {
        if (this.activeTool && this.context) {
          return this.activeTool.onMouseDown(event, this.context);
        }
        return false;
      }

      onMouseMove(event) {
        if (this.activeTool && this.context) {
          return this.activeTool.onMouseMove(event, this.context);
        }
        return false;
      }

      onMouseUp(event) {
        if (this.activeTool && this.context) {
          return this.activeTool.onMouseUp(event, this.context);
        }
        return false;
      }

      onKeyDown(event) {
        if (this.activeTool && this.context) {
          return this.activeTool.onKeyDown(event, this.context);
        }
        return false;
      }

      onKeyUp(event) {
        if (this.activeTool && this.context) {
          return this.activeTool.onKeyUp(event, this.context);
        }
        return false;
      }

      onDoubleClick(event) {
        if (this.activeTool && this.context) {
          return this.activeTool.onDoubleClick(event, this.context);
        }
        return false;
      }

      renderOverlay(ctx) {
        if (this.activeTool && this.context) {
          this.activeTool.renderOverlay(ctx, this.context);
        }
      }
    }

    // ============================================================
    // HOTKEY MANAGER
    // ============================================================

    class HotkeyManager {
      constructor() {
        this.bindings = new Map();
        this.contexts = [];
      }

      register(combo, action, context = 'global') {
        const key = `${context}:${combo.toLowerCase()}`;
        this.bindings.set(key, action);
      }

      handleKeyDown(event) {
        const combo = this.eventToCombo(event);

        // Check context-specific first, then global
        for (const ctx of [...this.contexts, 'global']) {
          const key = `${ctx}:${combo}`;
          if (this.bindings.has(key)) {
            event.preventDefault();
            this.bindings.get(key)();
            return true;
          }
        }
        return false;
      }

      eventToCombo(event) {
        const parts = [];
        if (event.ctrlKey || event.metaKey) parts.push('ctrl');
        if (event.shiftKey) parts.push('shift');
        if (event.altKey) parts.push('alt');

        let key = event.key.toLowerCase();
        if (key === ' ') key = 'space';
        parts.push(key);

        return parts.join('+');
      }

      pushContext(context) {
        this.contexts.push(context);
      }

      popContext() {
        return this.contexts.pop();
      }
    }

    // ============================================================
    // RENDERER
    // ============================================================

    class Renderer {
      constructor(canvas, grid) {
        this.canvas = canvas;
        this.ctx = canvas.getContext('2d');
        this.grid = grid;
        this.fontLoaded = false;
      }

      async loadFont() {
        try {
          await document.fonts.load('16px BerkeleyMono');
          this.fontLoaded = true;
          console.log('BerkeleyMono font loaded');
        } catch (e) {
          console.warn('Could not load BerkeleyMono, using fallback');
        }
      }

      setCanvasSize(width, height) {
        const dpr = window.devicePixelRatio || 1;
        this.canvas.width = width * dpr;
        this.canvas.height = height * dpr;
        this.canvas.style.width = width + 'px';
        this.canvas.style.height = height + 'px';
        this.ctx.scale(dpr, dpr);
      }

      clear() {
        const styles = getComputedStyle(document.documentElement);
        const bgCanvas = styles.getPropertyValue('--bg-canvas').trim() || '#1a1a1a';
        this.ctx.fillStyle = bgCanvas;
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
      }

      drawGrid(cols, rows, showGrid) {
        if (!showGrid) return;

        const styles = getComputedStyle(document.documentElement);
        const gridColor = styles.getPropertyValue('--bg-grid').trim() || '#2a2a2a';
        this.ctx.strokeStyle = gridColor;
        this.ctx.lineWidth = 0.5;

        // Vertical lines
        for (let c = 0; c <= cols; c++) {
          const x = c * this.grid.charWidth;
          this.ctx.beginPath();
          this.ctx.moveTo(x, 0);
          this.ctx.lineTo(x, rows * this.grid.charHeight);
          this.ctx.stroke();
        }

        // Horizontal lines
        for (let r = 0; r <= rows; r++) {
          const y = r * this.grid.charHeight;
          this.ctx.beginPath();
          this.ctx.moveTo(0, y);
          this.ctx.lineTo(cols * this.grid.charWidth, y);
          this.ctx.stroke();
        }
      }

      drawChar(char, col, row, color = null) {
        const font = this.fontLoaded ? 'BerkeleyMono' : 'monospace';
        this.ctx.font = `16px ${font}`;

        if (color === null) {
          const styles = getComputedStyle(document.documentElement);
          color = styles.getPropertyValue('--text-canvas').trim() || '#cccccc';
        }
        this.ctx.fillStyle = color;
        this.ctx.textBaseline = 'top';

        const x = col * this.grid.charWidth;
        const y = row * this.grid.charHeight;
        this.ctx.fillText(char, x, y + 2); // +2 for vertical alignment
      }

      drawText(text, col, row, color = null) {
        for (let i = 0; i < text.length; i++) {
          this.drawChar(text[i], col + i, row, color);
        }
      }

      drawBox(obj) {
        const { x, y, width, height, style, shadow } = obj;

        // Box drawing characters
        const chars = {
          single: { tl: '┌', tr: '┐', bl: '└', br: '┘', h: '─', v: '│' },
          double: { tl: '╔', tr: '╗', bl: '╚', br: '╝', h: '═', v: '║' },
          rounded: { tl: '╭', tr: '╮', bl: '╰', br: '╯', h: '─', v: '│' }
        };

        const c = chars[style] || chars.single;
        const styles = getComputedStyle(document.documentElement);
        const color = styles.getPropertyValue('--text-canvas').trim() || '#cccccc';
        const shadowColor = styles.getPropertyValue('--text-shadow').trim() || '#555555';
        const titleColor = styles.getPropertyValue('--accent').trim() || '#007acc';

        // Draw shadow first if enabled
        if (shadow) {
          for (let row = 1; row <= height; row++) {
            this.drawChar('░', x + width, y + row, shadowColor);
          }
          for (let col = 1; col < width; col++) {
            this.drawChar('░', x + col, y + height, shadowColor);
          }
          this.drawChar('░', x + width, y + height, shadowColor);
        }

        // Top border
        this.drawChar(c.tl, x, y, color);
        for (let col = 1; col < width - 1; col++) {
          this.drawChar(c.h, x + col, y, color);
        }
        this.drawChar(c.tr, x + width - 1, y, color);

        // Sides
        for (let row = 1; row < height - 1; row++) {
          this.drawChar(c.v, x, y + row, color);
          this.drawChar(c.v, x + width - 1, y + row, color);
        }

        // Bottom border
        this.drawChar(c.bl, x, y + height - 1, color);
        for (let col = 1; col < width - 1; col++) {
          this.drawChar(c.h, x + col, y + height - 1, color);
        }
        this.drawChar(c.br, x + width - 1, y + height - 1, color);

        // Draw title if present
        if (obj.title) {
          const titlePos = obj.titlePosition || 'top-left';
          const titleMode = obj.titleMode || 'border';
          const [titleV, titleH] = titlePos.split('-');
          const titleText = obj.title;
          const maxTitleLen = width - 4;  // Leave room for borders and spacing
          const displayTitle = titleText.length > maxTitleLen ? titleText.substring(0, maxTitleLen) : titleText;

          let titleX, titleY;

          // Vertical position based on mode
          if (titleV === 'top') {
            if (titleMode === 'outside') {
              titleY = y - 1;  // Above the box
            } else if (titleMode === 'inside') {
              titleY = y + 1;  // Inside, first row
            } else {  // border
              titleY = y;  // On the top border
            }
          } else if (titleV === 'bottom') {
            if (titleMode === 'outside') {
              titleY = y + height;  // Below the box
            } else if (titleMode === 'inside') {
              titleY = y + height - 2;  // Inside, last row
            } else {  // border
              titleY = y + height - 1;  // On the bottom border
            }
          }

          // Horizontal position
          if (titleH === 'left') {
            titleX = titleMode === 'inside' ? x + 1 : x + 2;
          } else if (titleH === 'center') {
            titleX = x + Math.floor((width - displayTitle.length) / 2);
          } else if (titleH === 'right') {
            titleX = titleMode === 'inside' ? x + width - displayTitle.length - 1 : x + width - displayTitle.length - 2;
          }

          // Draw title
          this.drawText(displayTitle, titleX, titleY, titleColor);
        }

        // Draw multi-line text inside with 9-position justification
        if (obj.text) {
          const innerWidth = width - 2;
          const innerHeight = height - 2;
          const lines = obj.text.split('\n');

          // Limit lines to fit in box
          const maxLines = innerHeight;
          const displayLines = lines.slice(0, maxLines);

          const justify = obj.textJustify || 'center-center';
          const [vAlign, hAlign] = justify.split('-');

          // Calculate starting Y based on vertical alignment
          let startY;
          if (vAlign === 'top') {
            startY = y + 1;
          } else if (vAlign === 'bottom') {
            startY = y + height - 1 - displayLines.length;
          } else {  // center
            startY = y + 1 + Math.floor((innerHeight - displayLines.length) / 2);
          }

          // Draw each line
          displayLines.forEach((line, i) => {
            const displayLine = line.length > innerWidth ? line.substring(0, innerWidth) : line;
            let textX;

            if (hAlign === 'left') {
              textX = x + 1;
            } else if (hAlign === 'right') {
              textX = x + width - 1 - displayLine.length;
            } else {  // center
              textX = x + 1 + Math.floor((innerWidth - displayLine.length) / 2);
            }

            this.drawText(displayLine, textX, startY + i, color);
          });
        }
      }

      drawObject(obj) {
        switch (obj.type) {
          case 'box':
            this.drawBox(obj);
            break;
          case 'text':
            this.drawText(obj.text || '', obj.x, obj.y);
            break;
          // Add more object types as we implement them
          default:
            // Placeholder for unimplemented types
            this.drawBox({ ...obj, width: obj.width || 10, height: obj.height || 3 });
        }
      }

      render(state, toolManager, editContext = null) {
        this.clear();

        const page = state.project.pages.find(p => p.id === state.activePageId);
        if (!page) return;

        // Draw grid
        this.drawGrid(page.width, page.height, state.ui.gridVisible);

        // Draw all objects
        page.objects.forEach(obj => {
          // If this object is being edited, use preview text
          if (editContext && editContext.objectId === obj.id && editContext.previewText !== null) {
            const previewObj = { ...obj, text: editContext.previewText };
            this.drawObject(previewObj);

            // Draw blinking cursor if visible
            if (editContext.cursorVisible) {
              this.drawEditCursor(previewObj, editContext.cursorPosition);
            }
          } else {
            this.drawObject(obj);
          }
        });

        // Draw tool overlay
        toolManager.renderOverlay(this.ctx);
      }

      drawEditCursor(obj, cursorPos) {
        if (!obj || obj.type !== 'box') return;

        const innerWidth = obj.width - 2;
        const innerHeight = obj.height - 2;
        const lines = (obj.text || '').split('\n');
        const displayLines = lines.slice(0, innerHeight);

        const justify = obj.textJustify || 'center-center';
        const [vAlign, hAlign] = justify.split('-');

        // Calculate starting Y based on vertical alignment
        let startY;
        if (vAlign === 'top') {
          startY = obj.y + 1;
        } else if (vAlign === 'bottom') {
          startY = obj.y + obj.height - 1 - displayLines.length;
        } else {  // center
          startY = obj.y + 1 + Math.floor((innerHeight - displayLines.length) / 2);
        }

        // Get the line where cursor is
        const lineIndex = Math.min(cursorPos.line, displayLines.length);
        const lineText = displayLines[lineIndex] || '';
        const cursorCol = Math.min(cursorPos.col, innerWidth);

        // Calculate X based on horizontal alignment
        let lineStartX;
        if (hAlign === 'left') {
          lineStartX = obj.x + 1;
        } else if (hAlign === 'right') {
          lineStartX = obj.x + obj.width - 1 - lineText.length;
        } else {  // center
          lineStartX = obj.x + 1 + Math.floor((innerWidth - lineText.length) / 2);
        }

        const cursorX = lineStartX + cursorCol;
        const cursorY = startY + lineIndex;

        // Draw cursor as a vertical bar or block
        const styles = getComputedStyle(document.documentElement);
        const cursorColor = styles.getPropertyValue('--accent').trim() || '#007acc';

        const px = cursorX * this.grid.charWidth;
        const py = cursorY * this.grid.charHeight;

        this.ctx.fillStyle = cursorColor;
        this.ctx.fillRect(px, py + 2, 2, this.grid.charHeight - 4);
      }
    }

    // ============================================================
    // INITIAL STATE
    // ============================================================

    function createInitialState() {
      return {
        project: {
          meta: {
            name: 'Untitled',
            version: '1.0',
            created: new Date().toISOString(),
            modified: new Date().toISOString()
          },
          settings: {
            charWidth: 10,
            charHeight: 20,
            defaultPageWidth: 120,
            defaultPageHeight: 60,
            font: 'BerkeleyMono',
            fontSize: 16
          },
          parameters: {
            PROJECT_NAME: 'Untitled Project',
            AUTHOR: '',
            COMPANY: '',
            REVISION: '1.0',
            DATE: new Date().toISOString().split('T')[0]
          },
          pages: [
            {
              id: 'page-1',
              name: 'Main',
              width: 120,
              height: 60,
              parameters: {},
              objects: []
            }
          ],
          interfaces: [],
          nets: []
        },
        activePageId: 'page-1',
        viewState: {
          'page-1': { zoom: 1.0, panX: 0, panY: 0 }
        },
        selection: {
          ids: [],
          handles: null
        },
        activeTool: 'select',
        toolState: {},
        clipboard: {
          sourcePageId: null,
          objects: []
        },
        ui: {
          sidebarVisible: true,
          propertiesPanelVisible: true,
          pageListVisible: true,
          gridVisible: true,
          viewMode: 'single'
        },
        gridLayout: {
          columns: 3,
          pageSpacing: 20,
          zoom: 0.3,
          panX: 0,
          panY: 0
        },
        navigationStack: []
      };
    }

    // ============================================================
    // APPLICATION
    // ============================================================

    class Application {
      constructor() {
        this.canvas = document.getElementById('editor-canvas');
        this.history = new HistoryManager(createInitialState());
        this.grid = null;
        this.renderer = null;
        this.toolManager = new ToolManager();
        this.hotkeyManager = new HotkeyManager();

        this.init();
      }

      async init() {
        // Measure font and set up grid
        await this.setupFont();

        // Set up renderer
        this.renderer = new Renderer(this.canvas, this.grid);
        await this.renderer.loadFont();

        // Set up canvas size
        const state = this.history.getState();
        const page = state.project.pages.find(p => p.id === state.activePageId);
        this.updateCanvasSize(page);

        // Set up tools
        this.setupTools();

        // Set up hotkeys
        this.setupHotkeys();

        // Set up event listeners
        this.setupEventListeners();

        // Subscribe to state changes
        this.history.subscribe(() => {
          this.render();
          this.updateUI();
        });

        // Initial render
        this.render();
        this.updateUI();
        this.renderPageTabs();

        console.log('ASCII Diagram Editor initialized');
      }

      async setupFont() {
        // Try to load font and measure
        try {
          await document.fonts.load('16px BerkeleyMono');
        } catch (e) {
          console.warn('BerkeleyMono not loaded, using fallback measurements');
        }

        // Measure character dimensions
        const measureCanvas = document.createElement('canvas');
        const measureCtx = measureCanvas.getContext('2d');
        measureCtx.font = '16px BerkeleyMono, monospace';

        const metrics = measureCtx.measureText('M');
        const charWidth = Math.ceil(metrics.width);
        const charHeight = 20; // Approximate line height

        this.grid = new CharacterGrid(charWidth, charHeight);

        console.log(`Character dimensions: ${charWidth}x${charHeight}`);
      }

      updateCanvasSize(page) {
        if (!page || !this.grid) return;
        const width = page.width * this.grid.charWidth;
        const height = page.height * this.grid.charHeight;
        this.renderer.setCanvasSize(width, height);
      }

      setupTools() {
        // Register tools
        this.toolManager.register(new SelectTool());
        this.toolManager.register(new BoxTool());
        // Add more tools as we implement them

        // Set context
        this.toolManager.setContext({
          canvas: this.canvas,
          grid: this.grid,
          history: this.history,
          startInlineEdit: (obj) => this.startInlineEdit(obj)
        });

        // Activate default tool
        this.toolManager.activate('select');
      }

      setupHotkeys() {
        const hk = this.hotkeyManager;

        // Undo/Redo
        hk.register('ctrl+z', () => this.history.undo());
        hk.register('ctrl+y', () => this.history.redo());
        hk.register('ctrl+shift+z', () => this.history.redo());

        // Tools
        hk.register('v', () => this.setTool('select'));
        hk.register('b', () => this.setTool('box'));
        hk.register('t', () => this.setTool('text'));
        hk.register('l', () => this.setTool('line'));
        hk.register('s', () => this.setTool('symbol'));
        hk.register('w', () => this.setTool('wire'));
        hk.register('p', () => this.setTool('port'));
        hk.register('o', () => this.setTool('power'));

        // View
        hk.register('g', () => this.toggleGrid());

        // File operations
        hk.register('ctrl+s', () => this.saveProject());
        hk.register('ctrl+e', () => this.exportASCII());

        // Escape - exit edit mode or clear selection
        hk.register('escape', () => {
          // If editing, cancel edit mode
          if (this.editingObjectId) {
            this.cancelInlineEdit();
            return;
          }
          // Otherwise clear selection and go to select tool
          this.history.updateState(s => ({
            ...s,
            selection: { ids: [], handles: null }
          }));
          this.setTool('select');
        });
      }

      setupEventListeners() {
        // Canvas mouse events
        this.canvas.addEventListener('mousedown', (e) => this.handleMouseDown(e));
        this.canvas.addEventListener('mousemove', (e) => this.handleMouseMove(e));
        this.canvas.addEventListener('mouseup', (e) => this.handleMouseUp(e));
        this.canvas.addEventListener('dblclick', (e) => this.handleDoubleClick(e));

        // Keyboard events
        document.addEventListener('keydown', (e) => this.handleKeyDown(e));
        document.addEventListener('keyup', (e) => this.handleKeyUp(e));

        // Toolbar buttons
        document.querySelectorAll('.tool-btn[data-tool]').forEach(btn => {
          btn.addEventListener('click', () => {
            this.setTool(btn.dataset.tool);
          });
        });

        document.getElementById('btn-undo').addEventListener('click', () => this.history.undo());
        document.getElementById('btn-redo').addEventListener('click', () => this.history.redo());
        document.getElementById('btn-grid').addEventListener('click', () => this.toggleGrid());
        document.getElementById('btn-save').addEventListener('click', () => this.saveProject());
        document.getElementById('btn-load').addEventListener('click', () => this.loadProject());
        document.getElementById('btn-export').addEventListener('click', () => this.exportASCII());

        // Window resize
        window.addEventListener('resize', () => this.render());

        // Inline editor events
        this.inlineEditor = document.getElementById('inline-editor');
        this.editPreviewText = null;
        this.cursorVisible = true;
        this.cursorPosition = { line: 0, col: 0 };

        this.inlineEditor.addEventListener('blur', () => this.finishInlineEdit());
        this.inlineEditor.addEventListener('keydown', (e) => {
          // Stop propagation so hotkeys don't interfere
          e.stopPropagation();

          if (e.key === 'Escape') {
            this.cancelInlineEdit();
          } else if (e.key === 'Enter' && !e.shiftKey) {
            e.preventDefault();
            this.finishInlineEdit();
          }
        });

        // Real-time preview while typing
        this.inlineEditor.addEventListener('input', () => {
          this.editPreviewText = this.inlineEditor.value;
          this.updateCursorPosition();
          this.render();
        });

        // Track cursor position for blinking cursor
        this.inlineEditor.addEventListener('selectionchange', () => this.updateCursorPosition());
        this.inlineEditor.addEventListener('click', () => this.updateCursorPosition());
        this.inlineEditor.addEventListener('keyup', () => this.updateCursorPosition());

        // Cursor blink interval
        this.cursorBlinkInterval = setInterval(() => {
          if (this.editingObjectId) {
            this.cursorVisible = !this.cursorVisible;
            this.render();
          }
        }, 530);
      }

      updateCursorPosition() {
        if (!this.editingObjectId) return;

        const editor = this.inlineEditor;
        const text = editor.value;
        const selStart = editor.selectionStart;

        // Calculate line and column from selection position
        const textBefore = text.substring(0, selStart);
        const lines = textBefore.split('\n');
        this.cursorPosition = {
          line: lines.length - 1,
          col: lines[lines.length - 1].length
        };
      }

      // ============================================================
      // INLINE TEXT EDITING
      // ============================================================

      startInlineEdit(obj, initialChar = null) {
        if (!obj || obj.type !== 'box') return;

        // Get fresh object reference from state
        const state = this.history.getState();
        const page = state.project.pages.find(p => p.id === state.activePageId);
        if (!page) return;

        const freshObj = page.objects.find(o => o.id === obj.id);
        if (!freshObj) return;

        this.editingObjectId = freshObj.id;
        this.cursorVisible = true;  // Start with cursor visible

        const editor = this.inlineEditor;

        // Hide the inline editor visually but keep it functional for input
        // We'll render the text directly on the canvas instead
        editor.style.left = '-9999px';
        editor.style.top = '-9999px';
        editor.style.width = '200px';
        editor.style.height = '100px';
        editor.style.display = 'block';
        editor.style.opacity = '0';

        // Set current text or start with initial character
        if (initialChar !== null) {
          editor.value = initialChar;
          this.editPreviewText = initialChar;
          editor.focus();
          editor.setSelectionRange(editor.value.length, editor.value.length);
        } else {
          editor.value = freshObj.text || '';
          this.editPreviewText = freshObj.text || '';
          editor.focus();
          editor.select();
        }

        this.updateCursorPosition();
        this.render();
      }

      finishInlineEdit() {
        if (!this.editingObjectId) return;

        const state = this.history.getState();
        const page = state.project.pages.find(p => p.id === state.activePageId);
        if (!page) return;

        const obj = page.objects.find(o => o.id === this.editingObjectId);
        if (!obj) return;

        const editor = this.inlineEditor;
        const newText = editor.value;

        // Only commit if text changed
        if (newText !== (obj.text || '')) {
          this.history.execute(new ModifyObjectCommand(
            state.activePageId,
            obj.id,
            { text: obj.text || '' },
            { text: newText }
          ));
        }

        editor.style.display = 'none';
        editor.style.opacity = '1';
        this.editingObjectId = null;
        this.editPreviewText = null;
        this.render();
        this.updatePropertiesPanel();
      }

      cancelInlineEdit() {
        this.inlineEditor.style.display = 'none';
        this.inlineEditor.style.opacity = '1';
        this.editingObjectId = null;
        this.editPreviewText = null;
        this.render();
      }

      // ============================================================
      // PROPERTIES PANEL
      // ============================================================

      updatePropertiesPanel() {
        const state = this.history.getState();
        const content = document.getElementById('properties-content');

        if (state.selection.ids.length === 0) {
          content.innerHTML = '<div class="property-empty">No selection</div>';
          return;
        }

        const page = state.project.pages.find(p => p.id === state.activePageId);
        if (!page) return;

        // Get all selected objects
        const selectedObjects = state.selection.ids
          .map(id => page.objects.find(o => o.id === id))
          .filter(obj => obj != null);

        if (selectedObjects.length === 0) {
          content.innerHTML = '<div class="property-empty">No selection</div>';
          return;
        }

        if (selectedObjects.length === 1) {
          // Single selection - show full properties
          const obj = selectedObjects[0];
          if (obj.type === 'box') {
            this.renderBoxProperties(obj);
          } else {
            content.innerHTML = `<div class="property-empty">Unknown object type</div>`;
          }
        } else {
          // Multi-selection - show common properties
          this.renderMultiSelectProperties(selectedObjects);
        }
      }

      // Get common property values across multiple objects
      getCommonPropertyValue(objects, prop) {
        if (objects.length === 0) return { value: null, mixed: false };

        const firstValue = objects[0][prop];
        const allSame = objects.every(obj => {
          const val = obj[prop];
          // Handle comparison for different types
          if (val === firstValue) return true;
          if (val === undefined && firstValue === undefined) return true;
          if (val === '' && firstValue === '') return true;
          return false;
        });

        return {
          value: allSame ? firstValue : null,
          mixed: !allSame
        };
      }

      renderMultiSelectProperties(objects) {
        const content = document.getElementById('properties-content');
        const objectIds = objects.map(o => o.id);

        // Get common property values
        const props = {
          x: this.getCommonPropertyValue(objects, 'x'),
          y: this.getCommonPropertyValue(objects, 'y'),
          width: this.getCommonPropertyValue(objects, 'width'),
          height: this.getCommonPropertyValue(objects, 'height'),
          style: this.getCommonPropertyValue(objects, 'style'),
          shadow: this.getCommonPropertyValue(objects, 'shadow'),
          title: this.getCommonPropertyValue(objects, 'title'),
          titlePosition: this.getCommonPropertyValue(objects, 'titlePosition'),
          titleMode: this.getCommonPropertyValue(objects, 'titleMode'),
          textJustify: this.getCommonPropertyValue(objects, 'textJustify'),
          text: this.getCommonPropertyValue(objects, 'text')
        };

        // Helper to render input value
        const inputValue = (prop) => prop.mixed ? '' : (prop.value ?? '');
        const inputPlaceholder = (prop, defaultPlaceholder = '') => prop.mixed ? '...' : defaultPlaceholder;
        const selectValue = (prop, defaultVal) => prop.mixed ? '' : (prop.value ?? defaultVal);
        const checkboxState = (prop) => {
          if (prop.mixed) return { checked: false, indeterminate: true };
          return { checked: !!prop.value, indeterminate: false };
        };

        const shadowState = checkboxState(props.shadow);

        content.innerHTML = `
          <div class="property-group">
            <div class="property-group-title">${objects.length} Objects Selected</div>
          </div>

          <div class="property-group">
            <div class="property-group-title">Position</div>
            <div class="property-row">
              <span class="property-label">X</span>
              <input type="number" class="property-input ${props.x.mixed ? 'mixed' : ''}" id="prop-x"
                value="${inputValue(props.x)}" placeholder="${inputPlaceholder(props.x)}">
            </div>
            <div class="property-row">
              <span class="property-label">Y</span>
              <input type="number" class="property-input ${props.y.mixed ? 'mixed' : ''}" id="prop-y"
                value="${inputValue(props.y)}" placeholder="${inputPlaceholder(props.y)}">
            </div>
          </div>

          <div class="property-group">
            <div class="property-group-title">Size</div>
            <div class="property-row">
              <span class="property-label">Width</span>
              <input type="number" class="property-input ${props.width.mixed ? 'mixed' : ''}" id="prop-width"
                value="${inputValue(props.width)}" placeholder="${inputPlaceholder(props.width)}" min="3">
            </div>
            <div class="property-row">
              <span class="property-label">Height</span>
              <input type="number" class="property-input ${props.height.mixed ? 'mixed' : ''}" id="prop-height"
                value="${inputValue(props.height)}" placeholder="${inputPlaceholder(props.height)}" min="3">
            </div>
          </div>

          <div class="property-group">
            <div class="property-group-title">Style</div>
            <div class="property-row">
              <span class="property-label">Border</span>
              <select class="property-select ${props.style.mixed ? 'mixed' : ''}" id="prop-style">
                ${props.style.mixed ? '<option value="" selected>...</option>' : ''}
                <option value="single" ${selectValue(props.style, 'single') === 'single' ? 'selected' : ''}>Single</option>
                <option value="double" ${selectValue(props.style, '') === 'double' ? 'selected' : ''}>Double</option>
                <option value="rounded" ${selectValue(props.style, '') === 'rounded' ? 'selected' : ''}>Rounded</option>
              </select>
            </div>
            <div class="property-row">
              <label class="property-checkbox">
                <input type="checkbox" id="prop-shadow" ${shadowState.checked ? 'checked' : ''}>
                <span>Drop Shadow ${props.shadow.mixed ? '(mixed)' : ''}</span>
              </label>
            </div>
          </div>

          <div class="property-group">
            <div class="property-group-title">Title</div>
            <div class="property-row">
              <input type="text" class="property-input ${props.title.mixed ? 'mixed' : ''}" id="prop-title"
                value="${inputValue(props.title)}" placeholder="${inputPlaceholder(props.title, 'Box title')}">
            </div>
            <div class="property-row">
              <span class="property-label">Position</span>
              <select class="property-select ${props.titlePosition.mixed ? 'mixed' : ''}" id="prop-titlePosition">
                ${props.titlePosition.mixed ? '<option value="" selected>...</option>' : ''}
                <option value="top-left" ${selectValue(props.titlePosition, 'top-left') === 'top-left' ? 'selected' : ''}>Top Left</option>
                <option value="top-center" ${selectValue(props.titlePosition, '') === 'top-center' ? 'selected' : ''}>Top Center</option>
                <option value="top-right" ${selectValue(props.titlePosition, '') === 'top-right' ? 'selected' : ''}>Top Right</option>
                <option value="bottom-left" ${selectValue(props.titlePosition, '') === 'bottom-left' ? 'selected' : ''}>Bottom Left</option>
                <option value="bottom-center" ${selectValue(props.titlePosition, '') === 'bottom-center' ? 'selected' : ''}>Bottom Center</option>
                <option value="bottom-right" ${selectValue(props.titlePosition, '') === 'bottom-right' ? 'selected' : ''}>Bottom Right</option>
              </select>
            </div>
            <div class="property-row">
              <span class="property-label">Mode</span>
              <select class="property-select ${props.titleMode.mixed ? 'mixed' : ''}" id="prop-titleMode">
                ${props.titleMode.mixed ? '<option value="" selected>...</option>' : ''}
                <option value="border" ${selectValue(props.titleMode, 'border') === 'border' ? 'selected' : ''}>On Border</option>
                <option value="inside" ${selectValue(props.titleMode, '') === 'inside' ? 'selected' : ''}>Inside</option>
                <option value="outside" ${selectValue(props.titleMode, '') === 'outside' ? 'selected' : ''}>Outside</option>
              </select>
            </div>
          </div>

          <div class="property-group">
            <div class="property-group-title">Text Content</div>
            <div class="property-row">
              <span class="property-label">Justify</span>
            </div>
            <div class="justify-grid" id="justify-grid">
              <button class="justify-btn ${!props.textJustify.mixed && props.textJustify.value === 'top-left' ? 'active' : ''}" data-justify="top-left" title="Top Left">&#x2196;</button>
              <button class="justify-btn ${!props.textJustify.mixed && props.textJustify.value === 'top-center' ? 'active' : ''}" data-justify="top-center" title="Top Center">&#x2191;</button>
              <button class="justify-btn ${!props.textJustify.mixed && props.textJustify.value === 'top-right' ? 'active' : ''}" data-justify="top-right" title="Top Right">&#x2197;</button>
              <button class="justify-btn ${!props.textJustify.mixed && props.textJustify.value === 'center-left' ? 'active' : ''}" data-justify="center-left" title="Center Left">&#x2190;</button>
              <button class="justify-btn ${!props.textJustify.mixed && props.textJustify.value === 'center-center' ? 'active' : ''}" data-justify="center-center" title="Center">&#x25CF;</button>
              <button class="justify-btn ${!props.textJustify.mixed && props.textJustify.value === 'center-right' ? 'active' : ''}" data-justify="center-right" title="Center Right">&#x2192;</button>
              <button class="justify-btn ${!props.textJustify.mixed && props.textJustify.value === 'bottom-left' ? 'active' : ''}" data-justify="bottom-left" title="Bottom Left">&#x2199;</button>
              <button class="justify-btn ${!props.textJustify.mixed && props.textJustify.value === 'bottom-center' ? 'active' : ''}" data-justify="bottom-center" title="Bottom Center">&#x2193;</button>
              <button class="justify-btn ${!props.textJustify.mixed && props.textJustify.value === 'bottom-right' ? 'active' : ''}" data-justify="bottom-right" title="Bottom Right">&#x2198;</button>
            </div>
            <textarea class="property-textarea ${props.text.mixed ? 'mixed' : ''}" id="prop-text"
              placeholder="${inputPlaceholder(props.text, 'Text content')}">${inputValue(props.text)}</textarea>
          </div>
        `;

        // Set indeterminate state for checkbox after DOM is created
        const shadowCheck = document.getElementById('prop-shadow');
        if (shadowCheck && props.shadow.mixed) {
          shadowCheck.indeterminate = true;
        }

        // Wire up event listeners for multi-select
        this.wireMultiSelectListeners(objectIds);
      }

      wireMultiSelectListeners(objectIds) {
        // Position/Size inputs
        ['x', 'y', 'width', 'height'].forEach(prop => {
          const input = document.getElementById(`prop-${prop}`);
          if (input) {
            input.addEventListener('change', () => {
              const value = input.value;
              if (value === '') return;  // Don't update if empty (mixed state)
              let numValue = parseInt(value, 10);
              if (prop === 'width' || prop === 'height') {
                numValue = Math.max(3, numValue);
              }
              this.updateMultipleObjectsProperty(objectIds, prop, numValue);
            });
          }
        });

        // Style select
        const styleSelect = document.getElementById('prop-style');
        if (styleSelect) {
          styleSelect.addEventListener('change', () => {
            if (styleSelect.value === '') return;  // Mixed placeholder
            this.updateMultipleObjectsProperty(objectIds, 'style', styleSelect.value);
          });
        }

        // Shadow checkbox
        const shadowCheck = document.getElementById('prop-shadow');
        if (shadowCheck) {
          shadowCheck.addEventListener('change', () => {
            this.updateMultipleObjectsProperty(objectIds, 'shadow', shadowCheck.checked);
          });
        }

        // Title input
        const titleInput = document.getElementById('prop-title');
        if (titleInput) {
          titleInput.addEventListener('change', () => {
            this.updateMultipleObjectsProperty(objectIds, 'title', titleInput.value);
          });
        }

        // Title position select
        const titlePosSelect = document.getElementById('prop-titlePosition');
        if (titlePosSelect) {
          titlePosSelect.addEventListener('change', () => {
            if (titlePosSelect.value === '') return;
            this.updateMultipleObjectsProperty(objectIds, 'titlePosition', titlePosSelect.value);
          });
        }

        // Title mode select
        const titleModeSelect = document.getElementById('prop-titleMode');
        if (titleModeSelect) {
          titleModeSelect.addEventListener('change', () => {
            if (titleModeSelect.value === '') return;
            this.updateMultipleObjectsProperty(objectIds, 'titleMode', titleModeSelect.value);
          });
        }

        // Text justification grid buttons
        document.querySelectorAll('[data-justify]').forEach(btn => {
          btn.addEventListener('click', () => {
            this.updateMultipleObjectsProperty(objectIds, 'textJustify', btn.dataset.justify);
          });
        });

        // Text textarea
        const textArea = document.getElementById('prop-text');
        if (textArea) {
          textArea.addEventListener('change', () => {
            this.updateMultipleObjectsProperty(objectIds, 'text', textArea.value);
          });
        }
      }

      updateMultipleObjectsProperty(objectIds, property, value) {
        const state = this.history.getState();
        const page = state.project.pages.find(p => p.id === state.activePageId);
        if (!page) return;

        // Create modify commands for all objects
        objectIds.forEach(objectId => {
          const obj = page.objects.find(o => o.id === objectId);
          if (!obj) return;

          const oldValue = obj[property];
          if (oldValue === value) return;  // Skip if no change

          this.history.execute(new ModifyObjectCommand(
            state.activePageId,
            objectId,
            { [property]: oldValue },
            { [property]: value }
          ));
        });

        this.updatePropertiesPanel();
      }

      renderBoxProperties(obj) {
        const content = document.getElementById('properties-content');
        const justify = obj.textJustify || 'center-center';
        const titlePos = obj.titlePosition || 'top-left';
        const titleMode = obj.titleMode || 'border';

        content.innerHTML = `
          <div class="property-group">
            <div class="property-group-title">Position</div>
            <div class="property-row">
              <span class="property-label">X</span>
              <input type="number" class="property-input" id="prop-x" value="${obj.x}">
            </div>
            <div class="property-row">
              <span class="property-label">Y</span>
              <input type="number" class="property-input" id="prop-y" value="${obj.y}">
            </div>
          </div>

          <div class="property-group">
            <div class="property-group-title">Size</div>
            <div class="property-row">
              <span class="property-label">Width</span>
              <input type="number" class="property-input" id="prop-width" value="${obj.width}" min="3">
            </div>
            <div class="property-row">
              <span class="property-label">Height</span>
              <input type="number" class="property-input" id="prop-height" value="${obj.height}" min="3">
            </div>
          </div>

          <div class="property-group">
            <div class="property-group-title">Style</div>
            <div class="property-row">
              <span class="property-label">Border</span>
              <select class="property-select" id="prop-style">
                <option value="single" ${obj.style === 'single' ? 'selected' : ''}>Single</option>
                <option value="double" ${obj.style === 'double' ? 'selected' : ''}>Double</option>
                <option value="rounded" ${obj.style === 'rounded' ? 'selected' : ''}>Rounded</option>
              </select>
            </div>
            <div class="property-row">
              <label class="property-checkbox">
                <input type="checkbox" id="prop-shadow" ${obj.shadow ? 'checked' : ''}>
                <span>Drop Shadow</span>
              </label>
            </div>
          </div>

          <div class="property-group">
            <div class="property-group-title">Title</div>
            <div class="property-row">
              <input type="text" class="property-input" id="prop-title" value="${obj.title || ''}" placeholder="Box title">
            </div>
            <div class="property-row">
              <span class="property-label">Position</span>
              <select class="property-select" id="prop-titlePosition">
                <option value="top-left" ${titlePos === 'top-left' ? 'selected' : ''}>Top Left</option>
                <option value="top-center" ${titlePos === 'top-center' ? 'selected' : ''}>Top Center</option>
                <option value="top-right" ${titlePos === 'top-right' ? 'selected' : ''}>Top Right</option>
                <option value="bottom-left" ${titlePos === 'bottom-left' ? 'selected' : ''}>Bottom Left</option>
                <option value="bottom-center" ${titlePos === 'bottom-center' ? 'selected' : ''}>Bottom Center</option>
                <option value="bottom-right" ${titlePos === 'bottom-right' ? 'selected' : ''}>Bottom Right</option>
              </select>
            </div>
            <div class="property-row">
              <span class="property-label">Mode</span>
              <select class="property-select" id="prop-titleMode">
                <option value="border" ${titleMode === 'border' ? 'selected' : ''}>On Border</option>
                <option value="inside" ${titleMode === 'inside' ? 'selected' : ''}>Inside</option>
                <option value="outside" ${titleMode === 'outside' ? 'selected' : ''}>Outside</option>
              </select>
            </div>
          </div>

          <div class="property-group">
            <div class="property-group-title">Text Content</div>
            <div class="property-row">
              <span class="property-label">Justify</span>
            </div>
            <div class="justify-grid" id="justify-grid">
              <button class="justify-btn ${justify === 'top-left' ? 'active' : ''}" data-justify="top-left" title="Top Left">&#x2196;</button>
              <button class="justify-btn ${justify === 'top-center' ? 'active' : ''}" data-justify="top-center" title="Top Center">&#x2191;</button>
              <button class="justify-btn ${justify === 'top-right' ? 'active' : ''}" data-justify="top-right" title="Top Right">&#x2197;</button>
              <button class="justify-btn ${justify === 'center-left' ? 'active' : ''}" data-justify="center-left" title="Center Left">&#x2190;</button>
              <button class="justify-btn ${justify === 'center-center' ? 'active' : ''}" data-justify="center-center" title="Center">&#x25CF;</button>
              <button class="justify-btn ${justify === 'center-right' ? 'active' : ''}" data-justify="center-right" title="Center Right">&#x2192;</button>
              <button class="justify-btn ${justify === 'bottom-left' ? 'active' : ''}" data-justify="bottom-left" title="Bottom Left">&#x2199;</button>
              <button class="justify-btn ${justify === 'bottom-center' ? 'active' : ''}" data-justify="bottom-center" title="Bottom Center">&#x2193;</button>
              <button class="justify-btn ${justify === 'bottom-right' ? 'active' : ''}" data-justify="bottom-right" title="Bottom Right">&#x2198;</button>
            </div>
            <textarea class="property-textarea" id="prop-text" placeholder="Type when selected or double-click to edit">${obj.text || ''}</textarea>
          </div>
        `;

        // Wire up event listeners
        this.wirePropertyListeners(obj);
      }

      wirePropertyListeners(obj) {
        const state = this.history.getState();

        // Position/Size inputs
        ['x', 'y', 'width', 'height'].forEach(prop => {
          const input = document.getElementById(`prop-${prop}`);
          if (input) {
            input.addEventListener('change', () => {
              let value = parseInt(input.value, 10);
              if (prop === 'width' || prop === 'height') {
                value = Math.max(3, value);  // Minimum size
              }
              this.updateObjectProperty(obj.id, prop, value);
            });
          }
        });

        // Style select
        const styleSelect = document.getElementById('prop-style');
        if (styleSelect) {
          styleSelect.addEventListener('change', () => {
            this.updateObjectProperty(obj.id, 'style', styleSelect.value);
          });
        }

        // Shadow checkbox
        const shadowCheck = document.getElementById('prop-shadow');
        if (shadowCheck) {
          shadowCheck.addEventListener('change', () => {
            this.updateObjectProperty(obj.id, 'shadow', shadowCheck.checked);
          });
        }

        // Title input
        const titleInput = document.getElementById('prop-title');
        if (titleInput) {
          titleInput.addEventListener('change', () => {
            this.updateObjectProperty(obj.id, 'title', titleInput.value);
          });
        }

        // Title position select
        const titlePosSelect = document.getElementById('prop-titlePosition');
        if (titlePosSelect) {
          titlePosSelect.addEventListener('change', () => {
            this.updateObjectProperty(obj.id, 'titlePosition', titlePosSelect.value);
          });
        }

        // Title mode select
        const titleModeSelect = document.getElementById('prop-titleMode');
        if (titleModeSelect) {
          titleModeSelect.addEventListener('change', () => {
            this.updateObjectProperty(obj.id, 'titleMode', titleModeSelect.value);
          });
        }

        // Text justification grid buttons
        document.querySelectorAll('[data-justify]').forEach(btn => {
          btn.addEventListener('click', () => {
            this.updateObjectProperty(obj.id, 'textJustify', btn.dataset.justify);
          });
        });

        // Text textarea
        const textArea = document.getElementById('prop-text');
        if (textArea) {
          textArea.addEventListener('change', () => {
            this.updateObjectProperty(obj.id, 'text', textArea.value);
          });
        }
      }

      updateObjectProperty(objectId, property, value) {
        const state = this.history.getState();
        const page = state.project.pages.find(p => p.id === state.activePageId);
        if (!page) return;

        const obj = page.objects.find(o => o.id === objectId);
        if (!obj) return;

        const oldValue = obj[property];
        if (oldValue === value) return;

        this.history.execute(new ModifyObjectCommand(
          state.activePageId,
          objectId,
          { [property]: oldValue },
          { [property]: value }
        ));

        this.updatePropertiesPanel();
      }

      handleMouseDown(e) {
        // If editing, finish edit first before processing mouse event
        if (this.editingObjectId) {
          this.finishInlineEdit();
        }

        const rect = this.canvas.getBoundingClientRect();
        const event = {
          canvasX: e.clientX - rect.left,
          canvasY: e.clientY - rect.top,
          button: e.button,
          shiftKey: e.shiftKey,
          ctrlKey: e.ctrlKey,
          altKey: e.altKey
        };

        if (this.toolManager.onMouseDown(event)) {
          this.render();
        }
      }

      handleMouseMove(e) {
        const rect = this.canvas.getBoundingClientRect();
        const event = {
          canvasX: e.clientX - rect.left,
          canvasY: e.clientY - rect.top,
          button: e.button,
          shiftKey: e.shiftKey,
          ctrlKey: e.ctrlKey,
          altKey: e.altKey
        };

        // Update status bar position
        const { col, row } = this.grid.pixelToChar(event.canvasX, event.canvasY);
        document.getElementById('status-position').textContent = `Col: ${col}, Row: ${row}`;

        if (this.toolManager.onMouseMove(event)) {
          this.render();
        }
      }

      handleMouseUp(e) {
        const rect = this.canvas.getBoundingClientRect();
        const event = {
          canvasX: e.clientX - rect.left,
          canvasY: e.clientY - rect.top,
          button: e.button,
          shiftKey: e.shiftKey,
          ctrlKey: e.ctrlKey,
          altKey: e.altKey
        };

        if (this.toolManager.onMouseUp(event)) {
          this.render();
        }
      }

      handleDoubleClick(e) {
        const rect = this.canvas.getBoundingClientRect();
        const event = {
          canvasX: e.clientX - rect.left,
          canvasY: e.clientY - rect.top
        };

        if (this.toolManager.onDoubleClick(event)) {
          this.render();
        }
      }

      handleKeyDown(e) {
        // Don't intercept keys when inline editor is active
        if (this.editingObjectId && document.activeElement === this.inlineEditor) {
          return;
        }

        // Don't intercept when focused on input/textarea in properties panel
        if (document.activeElement.tagName === 'INPUT' ||
            document.activeElement.tagName === 'TEXTAREA') {
          return;
        }

        // First try hotkey manager
        if (this.hotkeyManager.handleKeyDown(e)) {
          this.render();
          this.updateUI();
          return;
        }

        // Then try active tool
        if (this.toolManager.onKeyDown(e)) {
          this.render();
        }
      }

      handleKeyUp(e) {
        if (this.toolManager.onKeyUp(e)) {
          this.render();
        }
      }

      setTool(toolName) {
        if (this.toolManager.activate(toolName)) {
          this.history.updateState(s => ({ ...s, activeTool: toolName }));
          this.updateUI();
        }
      }

      toggleGrid() {
        this.history.updateState(s => ({
          ...s,
          ui: { ...s.ui, gridVisible: !s.ui.gridVisible }
        }));
      }

      render() {
        const state = this.history.getState();

        // Build edit context if currently editing
        let editContext = null;
        if (this.editingObjectId) {
          editContext = {
            objectId: this.editingObjectId,
            previewText: this.editPreviewText,
            cursorVisible: this.cursorVisible,
            cursorPosition: this.cursorPosition
          };
        }

        this.renderer.render(state, this.toolManager, editContext);
      }

      updateUI() {
        const state = this.history.getState();

        // Update tool buttons
        document.querySelectorAll('.tool-btn[data-tool]').forEach(btn => {
          btn.classList.toggle('active', btn.dataset.tool === state.activeTool);
        });

        // Update status bar
        document.getElementById('status-tool').textContent = `Tool: ${state.activeTool}`;
        document.getElementById('status-selection').textContent = `Selected: ${state.selection.ids.length}`;
        document.getElementById('status-history').textContent =
          `History: ${this.history.undoStack.length}/${this.history.undoStack.length + this.history.redoStack.length}`;

        const pageIndex = state.project.pages.findIndex(p => p.id === state.activePageId);
        document.getElementById('status-page').textContent =
          `Page: ${pageIndex + 1}/${state.project.pages.length}`;

        // Update properties panel
        this.updatePropertiesPanel();
      }

      renderPageTabs() {
        const state = this.history.getState();
        const container = document.getElementById('page-tabs');
        container.innerHTML = '';

        state.project.pages.forEach((page, index) => {
          const tab = document.createElement('button');
          tab.className = 'page-tab' + (page.id === state.activePageId ? ' active' : '');
          tab.textContent = page.name;
          tab.addEventListener('click', () => this.switchPage(page.id));
          container.appendChild(tab);
        });

        // Add "+" button
        const addBtn = document.createElement('button');
        addBtn.className = 'page-tab-add';
        addBtn.textContent = '+';
        addBtn.addEventListener('click', () => this.addPage());
        container.appendChild(addBtn);
      }

      switchPage(pageId) {
        this.history.updateState(s => ({
          ...s,
          activePageId: pageId,
          selection: { ids: [], handles: null }
        }));

        const state = this.history.getState();
        const page = state.project.pages.find(p => p.id === pageId);
        this.updateCanvasSize(page);
        this.renderPageTabs();
        this.updateUI();
      }

      addPage() {
        const state = this.history.getState();
        const newPage = {
          id: generateId(),
          name: `Page ${state.project.pages.length + 1}`,
          width: state.project.settings.defaultPageWidth,
          height: state.project.settings.defaultPageHeight,
          parameters: {},
          objects: []
        };

        this.history.updateState(s => ({
          ...s,
          project: {
            ...s.project,
            pages: [...s.project.pages, newPage]
          },
          activePageId: newPage.id,
          viewState: {
            ...s.viewState,
            [newPage.id]: { zoom: 1.0, panX: 0, panY: 0 }
          }
        }));

        this.updateCanvasSize(newPage);
        this.renderPageTabs();
        this.updateUI();
      }

      saveProject() {
        const state = this.history.getState();
        const json = JSON.stringify(state.project, null, 2);
        const blob = new Blob([json], { type: 'application/json' });
        const url = URL.createObjectURL(blob);

        const a = document.createElement('a');
        a.href = url;
        a.download = (state.project.meta.name || 'diagram') + '.json';
        a.click();

        URL.revokeObjectURL(url);
        console.log('Project saved');
      }

      loadProject() {
        const input = document.createElement('input');
        input.type = 'file';
        input.accept = '.json';
        input.onchange = (e) => {
          const file = e.target.files[0];
          if (!file) return;

          const reader = new FileReader();
          reader.onload = (e) => {
            try {
              const project = JSON.parse(e.target.result);
              this.history.updateState(s => ({
                ...s,
                project,
                activePageId: project.pages[0]?.id || 'page-1',
                selection: { ids: [], handles: null }
              }));

              const state = this.history.getState();
              const page = state.project.pages.find(p => p.id === state.activePageId);
              this.updateCanvasSize(page);
              this.renderPageTabs();
              this.updateUI();
              console.log('Project loaded');
            } catch (err) {
              console.error('Failed to load project:', err);
              alert('Failed to load project file');
            }
          };
          reader.readAsText(file);
        };
        input.click();
      }

      exportASCII() {
        const state = this.history.getState();
        const page = state.project.pages.find(p => p.id === state.activePageId);
        if (!page) return;

        // Create a 2D character buffer
        const buffer = [];
        for (let r = 0; r < page.height; r++) {
          buffer.push(new Array(page.width).fill(' '));
        }

        // Render objects to buffer
        page.objects.forEach(obj => {
          this.renderObjectToBuffer(buffer, obj);
        });

        // Convert buffer to string
        const ascii = buffer.map(row => row.join('')).join('\n');

        // Download
        const blob = new Blob([ascii], { type: 'text/plain' });
        const url = URL.createObjectURL(blob);

        const a = document.createElement('a');
        a.href = url;
        a.download = (page.name || 'diagram') + '.txt';
        a.click();

        URL.revokeObjectURL(url);
        console.log('ASCII exported');
      }

      renderObjectToBuffer(buffer, obj) {
        if (obj.type === 'box') {
          this.renderBoxToBuffer(buffer, obj);
        }
        // Add more object types as implemented
      }

      renderBoxToBuffer(buffer, obj) {
        const { x, y, width, height, style, text, shadow } = obj;

        const chars = {
          single: { tl: '┌', tr: '┐', bl: '└', br: '┘', h: '─', v: '│' },
          double: { tl: '╔', tr: '╗', bl: '╚', br: '╝', h: '═', v: '║' },
          rounded: { tl: '╭', tr: '╮', bl: '╰', br: '╯', h: '─', v: '│' }
        };

        const c = chars[style] || chars.single;

        // Bounds checking helper
        const setChar = (col, row, char) => {
          if (row >= 0 && row < buffer.length && col >= 0 && col < buffer[0].length) {
            buffer[row][col] = char;
          }
        };

        // Draw shadow first if enabled
        if (shadow) {
          for (let row = 1; row <= height; row++) {
            setChar(x + width, y + row, '░');
          }
          for (let col = 1; col < width; col++) {
            setChar(x + col, y + height, '░');
          }
          setChar(x + width, y + height, '░');
        }

        // Top border
        setChar(x, y, c.tl);
        for (let col = 1; col < width - 1; col++) {
          setChar(x + col, y, c.h);
        }
        setChar(x + width - 1, y, c.tr);

        // Sides
        for (let row = 1; row < height - 1; row++) {
          setChar(x, y + row, c.v);
          setChar(x + width - 1, y + row, c.v);
        }

        // Bottom border
        setChar(x, y + height - 1, c.bl);
        for (let col = 1; col < width - 1; col++) {
          setChar(x + col, y + height - 1, c.h);
        }
        setChar(x + width - 1, y + height - 1, c.br);

        // Title
        if (obj.title) {
          const titlePos = obj.titlePosition || 'top-left';
          const titleMode = obj.titleMode || 'border';
          const [titleV, titleH] = titlePos.split('-');
          const maxTitleLen = width - 4;
          const displayTitle = obj.title.length > maxTitleLen ? obj.title.substring(0, maxTitleLen) : obj.title;

          let titleX, titleY;

          // Vertical position based on mode
          if (titleV === 'top') {
            if (titleMode === 'outside') {
              titleY = y - 1;
            } else if (titleMode === 'inside') {
              titleY = y + 1;
            } else {
              titleY = y;
            }
          } else if (titleV === 'bottom') {
            if (titleMode === 'outside') {
              titleY = y + height;
            } else if (titleMode === 'inside') {
              titleY = y + height - 2;
            } else {
              titleY = y + height - 1;
            }
          }

          // Horizontal position
          if (titleH === 'left') {
            titleX = titleMode === 'inside' ? x + 1 : x + 2;
          } else if (titleH === 'center') {
            titleX = x + Math.floor((width - displayTitle.length) / 2);
          } else if (titleH === 'right') {
            titleX = titleMode === 'inside' ? x + width - displayTitle.length - 1 : x + width - displayTitle.length - 2;
          }

          for (let i = 0; i < displayTitle.length; i++) {
            setChar(titleX + i, titleY, displayTitle[i]);
          }
        }

        // Multi-line text with justification
        if (text) {
          const innerWidth = width - 2;
          const innerHeight = height - 2;
          const lines = text.split('\n');
          const maxLines = innerHeight;
          const displayLines = lines.slice(0, maxLines);

          const justify = obj.textJustify || 'center-center';
          const [vAlign, hAlign] = justify.split('-');

          let startY;
          if (vAlign === 'top') {
            startY = y + 1;
          } else if (vAlign === 'bottom') {
            startY = y + height - 1 - displayLines.length;
          } else {
            startY = y + 1 + Math.floor((innerHeight - displayLines.length) / 2);
          }

          displayLines.forEach((line, i) => {
            const displayLine = line.length > innerWidth ? line.substring(0, innerWidth) : line;
            let textX;

            if (hAlign === 'left') {
              textX = x + 1;
            } else if (hAlign === 'right') {
              textX = x + width - 1 - displayLine.length;
            } else {
              textX = x + 1 + Math.floor((innerWidth - displayLine.length) / 2);
            }

            for (let j = 0; j < displayLine.length; j++) {
              setChar(textX + j, startY + i, displayLine[j]);
            }
          });
        }
      }
    }

    // ============================================================
    // BOOTSTRAP
    // ============================================================

    const app = new Application();
  </script>
</body>
</html>
